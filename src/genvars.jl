# Types for storing data about genvars
struct Fallback
    isimplemented::Function # function of model, dependency genvars, and rng types (e.g. (M, S, A, RNG))
    impl::Function          # actual function that is called to create the fallback value. Function of model, dependency genvars, and rng (e.g. (m, s, a, rng))
    suggest::Function       # function of an io object, model, dependency genvars, and rng (e.g. (io, m, s, a, rng))
end

Fallback(object) = Fallback((_...)->true, (_...)->object, (io, _...)->print(io, "<No suggestion provided. (this point should never be reached)>"))

struct GenVarData
    mod::Module
    longname::String
    descripton::String
    deps::Function # function of the model type
    type::Function # function of the model type - only used if things depend on it; can be abstract
    fallback::Union{Fallback,Nothing}
end

GenVarData(m, l, d, deps, t) = GenVarData(m, l, d, deps, t, nothing)

# Global registry of genvars
const genvar_registry = Dict{Symbol, GenVarData}()

# Public interface
"""
Print a short human-readable summary of all the genvars.
"""
function list_genvars()
    for v in genvars()
        data = genvar_data(v)
        println("genvar: :$v ($(data.longname))")
        println("module: $(data.mod)")
        println("description: $(data.descripton)")
        println()
    end
end

"""
    add_genvar(name::Symbol, data::GenVarData)

Add a genvar to the POMDPs.jl registry of genvars so that problems, solvers, and simulators may use it.
"""
function add_genvar(name::Symbol, data::GenVarData)
    genvar_registry[name] = data
    return name
end

"""
Return an iterator over all the genvars that POMDPs.jl knows about.
"""
genvars() = keys(genvar_registry)

"""
    genvar_data(genvar::Symbol)

Return a struct containing the data associated with a particular genvar.
"""
genvar_data(genvar::Symbol) = genvar_registry[genvar]
# <End public interface>

# just for convenience
rand_transition(m, s, a, rng) = rand(rng, transition(m, s, a))
rand_observation(m, s, a, sp, rng) = rand(rng, observation(m, s, a, sp))

# Create the basic genvars
genvar_registry[:s] = GenVarData(@__MODULE__, "state", "state at the beginning of the step", M->Symbol[], statetype)
genvar_registry[:a] = GenVarData(@__MODULE__, "action", "action taken by the agent", M->Symbol[], actiontype)

genvar_registry[:sp] = GenVarData(@__MODULE__,
                      "new state",
                      "state at the end of the step",
                      M->[:s, :a],
                      statetype,
                      Fallback(
                          (M, S, A, RNG) -> implemented(transition, Tuple{M,S,A}),
                          rand_transition,
                          function (io, m, s, a, rng)
                              print(io, schecked(@req(transition(m,s,a)), context=io))
                          end
                         ))

genvar_registry[:o] = GenVarData(@__MODULE__,
                     "observation",
                     "observation (usually depends on sp)",
                     M->[:s, :a, :sp],
                     obstype,
                     Fallback(
                         (M, S, A, SP, RNG) -> implemented(observation, Tuple{M,S,A,SP}),
                         rand_observation,
                         function (io, m, s, a, sp, rng)
                             print(io, schecked(@req(observation(m,s,a,sp)), context=io))
                         end
                        ))

genvar_registry[:r] = GenVarData(@__MODULE__,
                     "reward",
                     "reward generated by the step",
                     M-> M <: POMDP ? [:s, :a, :sp, :o] : [:s, :a, :sp],
                     M->Number,
                     # for fallback, just get rid of the rng arg
                     Fallback(
                         (argtypes...) -> implemented(reward, Tuple{argtypes[1:end-1]...}),
                         (args...) -> reward(args[1:end-1]...),
                         function (io, args...)
                             print(io, schecked(Req(reward, typeof(args[1:end-1])), context=io))
                         end
                        ))

# Utilities for genvars
"""
Create a list of genvars sorted so that dependencies come before dependents.
"""
function sorted_genvars(M::Type, symbols)
    dag = SimpleDiGraph(length(genvars()))
    labels = Symbol[]
    nodemap = Dict{Symbol, Int}()
    for sym in symbols
        if !haskey(nodemap, sym)
            push!(labels, sym)
            nodemap[sym] = length(labels)
        end
        add_dep_edges!(dag, nodemap, labels, M, sym)
    end
    sortednodes = topological_sort_by_dfs(dag)
    return labels[filter(n -> n<=length(labels), sortednodes)]
end

function add_dep_edges!(dag, nodemap, labels, M::Type, sym)
    deps = genvar_data(sym).deps(M)
    for dep in deps
        if !haskey(nodemap, dep)
            push!(labels, dep)
            nodemap[dep] = length(labels)
        end
        add_edge!(dag, nodemap[dep], nodemap[sym])
        add_dep_edges!(dag, nodemap, labels, M, dep)
    end
end
