struct Fallback
    isimplemented::Function
    impl::Function
    suggest::Function
end

struct GenVarData
    mod::Module
    longname::String
    descripton::String
    deps::Function
    type::Function # function of the model type - only used if things depend on it; can be abstract
    fallback::Union{Fallback,Nothing}
end

GenVarData(m, l, d, deps, t) = GenVarData(m, l, d, deps, t, nothing)

const genvars = Dict{Symbol, GenVarData}()

rand_transition(m, s, a, rng) = rand(rng, transition(m, s, a))
rand_observation(m, s, a, sp, rng) = rand(rng, observation(m, s, a, sp))

genvars[:s] = GenVarData(@__MODULE__, "state", "state at the beginning of the step", M->Symbol[], statetype)
genvars[:a] = GenVarData(@__MODULE__, "action", "action taken by the agent", M->Symbol[], actiontype)

genvars[:sp] = GenVarData(@__MODULE__,
                      "new state",
                      "state at the end of the step",
                      M->[:s, :a],
                      statetype,
                      Fallback(
                          (M, S, A, RNG) -> implemented(transition, Tuple{M,S,A}),
                          rand_transition,
                          function (io, m, s, a, rng)
                              print(io, "Implement transition(::$(typeof(m)), ::$(typeof(s)), ::$(typeof(a))).")
                          end
                         ))

genvars[:o] = GenVarData(@__MODULE__,
                     "observation",
                     "observation (usually depends on sp)",
                     M->[:s, :a, :sp],
                     obstype,
                     Fallback(
                         (M, S, A, SP, RNG) -> implemented(observation, Tuple{M,S,A,SP}),
                         rand_observation,
                         function (io, m, s, a, sp, rng)
                             print(io, "Implement observation(::$(typeof(m)), ::$(typeof(s)), ::$(typeof(a)), ::$(typeof(sp))).")
                         end
                        ))

genvars[:r] = GenVarData(@__MODULE__,
                     "reward",
                     "reward generated by the step",
                     M-> M <: POMDP ? [:s, :a, :sp, :o] : [:s, :a, :sp],
                     M->Number,
                     # for fallback, just get rid of the rng arg
                     Fallback(
                         (argtypes...) -> implemented(reward, Tuple{argtypes[1:end-1]...}),
                         (args...) -> reward(args[1:end-1]...),
                         function (io, args...)
                             argtypestring = join(("::$(typeof(a))" for a in args[1:end-1]), ", ")
                             print(io, "Implement reward($(argtypestring)).")
                         end
                        ))

function sorted_genvars(M::Type, symbols)
    dag = SimpleDiGraph(length(genvars))
    labels = Symbol[]
    nodemap = Dict{Symbol, Int}()
    for sym in symbols
        if !haskey(nodemap, sym)
            push!(labels, sym)
            nodemap[sym] = length(labels)
        end
        add_dep_edges!(dag, nodemap, labels, M, sym)
    end
    sortednodes = topological_sort_by_dfs(dag)
    return labels[filter(n -> n<=length(labels), sortednodes)]
end

function add_dep_edges!(dag, nodemap, labels, M::Type, sym)
    for dep in genvars[sym].deps(M)
        if !haskey(nodemap, dep)
            push!(labels, dep)
            nodemap[dep] = length(labels)
        end
        add_edge!(dag, nodemap[dep], nodemap[sym])
        add_dep_edges!(dag, nodemap, labels, M, dep)
    end
end
