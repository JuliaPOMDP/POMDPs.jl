# functions for models to provide
function gen end # always returns a NamedTuple
function genstate end
function genobs end


# functions for solvers and simulators to use
generate(v::Val{r::Symbol}, args...) = generate_default(r, args...)

@generated function generate(v::Val{r::Symbol}, m, s, a, rng)
    if r == :sp && implemented(genstate, Tuple{m,s,a,rng})
        return :(genstate(m,s,a,rng))
    end
    return :(first(generate(Val{($r,)}(), m, s, a, rng)))
end

@generated function generate(v::Val{t::Tuple}, m, s, a, rng) # always returns a NamedTuple

    @debug("Creating an implementation for generate(::Val{$S}, ::M, ::S, ::A, ::RNG)",
           M=m, S=s, A=a, RNG=rng)

    # use old generate_ function if available
    if implemented(old_generate_function(v), Tuple{m, s, a, rng})
        @warn("")
        return :($(old_generate_function(v))(m, s, a, rng))
    end

    # use anything available from gen
    if implemented(gen, Tuple{m,s,a,rng})
        @debug("Found gen(::M, ::S, ::A, ::RNG)::N", M=m, S=s, A=a, RNG=rng)
        expr = quote
            x = gen(m, s, a, rng)
            @assert x isa NamedTuple "gen(...) must return a NamedTuple; got $(typeof(x))"
        end
    else
        expr = quote x = NamedTuple() end
    end

    # fill in any elements that might be missing
    return_tuple_elements = Expr[]
    @assert expr.head = :block
    for var::Symbol in v.parameters
        sym = Meta.quot(var)
        genvarargs = genvars[var].deps
        varblock = quote
            if haskey(x, $sym)
                $var = x[$sym]
            else
                $var = generate_default(sym, m, $(genvarargs...), rng)
            end
        end
        append!(expr.args, varblock.args)
        push!(return_tuple_elements, :($var=$var))
    end
    return_expr = :(return ($(return_tuple_elements...)))
    append!(expr.args, return_expr.args)

    @debug("Implementing generate(::Val{$S}, ::M, ::S, ::A, ::RNG) with:\n$expr")
    return expr
end

struct GenVarData
    mod::Module #?
    longname::String
    descripton::String
    deps::Array{Symbol}
end

const genvars = Dict{Symbol, GenVarData}()
genvars[:s] = GenVarData(@__Module__, "state", "state at the beginning of the step", Symbol[])
genvars[:a] = GenVarData(@__Module__, "action", "action taken by the agent", Symbol[])
genvars[:sp] = GenVarData(@__Module__, "new state", "state at the end of the step", [:s, :a])
genvars[:o] = GenVarData(@__Module__, "observation", "observation (usually depends on sp)", [:s, :a, :sp])
genvars[:r] = GenVarData(@__Module__, "reward", "reward generated by the step", [:s, :a, :sp, :o])

@generated function generate_default(::Val{:sp}, m, s, a, rng)
    if implemented(genstate, Tuple{m,s,a,rng})
        expr = :(genstate(m, s, a, rng))
    elseif implemented(transition, Tuple{m,s,a})
        expr = :(rand(rng, transition(m, s, a)))
    elseif implemented(generate_s, Tuple{m,s,a,rng}) 
        # TODO warn
        expr = :(generate_s(m, s, a, rng))
    else
        expr = quote
            try
                genstate(m,s,a,rng)
                transition(m,s,a)
            catch ex
                @assert ex isa MethodError
                throw_genvar_error(:sp, [Req(genstate, Tuple{m,s,a,rng}),
                                         Req(transition, Tuple{m,s,a}),
                                         CheckGen(:sp, m, s, a, rng)
                                        ])
            end
        end
    end
    @debug("Fallback expression for `sp` is:\n$expr")
    return expr
end

@generated function generate_default(::Val{:o}, m, s, a, sp, rng)
    if implemented(genobs, Tuple{m,s,a,sp,rng})
        expr = :(genobs(m, s, a, sp, rng))
    elseif implemented(observation, Tuple{m,s,a,sp})
        expr = :(rand(rng, observation(m, s, a, sp)))
    elseif implemented(generate_o, Tuple{m,s,a,sp,rng})
        # TODO
        @warn("")
        expr = :(generate_o(m,s,a,sp,rng))
    else
        expr = quote
            try
                genobs(m,s,a,sp,rng) # for backedges; should throw a MethodError
                observation(m,s,a,sp)
            catch ex
                @assert ex isa MethodError
                throw(GenerateDefaultError(:o, suggestions=[Req(genobs, Tuple{m,s,a,sp,rng}),
                                                            Req(observation, Tuple{m,s,a,sp}),
                                                            CheckGen(:o, m,s,a,rng)
                                                           ]))
            end
        end
    end
    @debug("Fallback expression for `o` is:\n$expr")
    return expr
end

@generated function generate_default(::Val{:r}, m, s, a, sp, o, rng)
    if implemented(reward, Tuple{m,s,a,sp,o})
        expr = :(reward(m, s, a, sp, o))
    else
        expr = quote
            try
                return reward(m, s, a, sp, o) # for backedges; should throw a MethodError
            catch ex
                @assert ex isa MethodError
                throw(GenerateDefaultError(:r, suggestions=[Req(reward, $(Tuple{m,s,a,sp,o})),
                                                            CheckGen(:r, m,s,a,rng)
                                                           ]))
            end
        end
    end
    @debug("Fallback expression for `r` is:\n$expr")
    return expr
end
