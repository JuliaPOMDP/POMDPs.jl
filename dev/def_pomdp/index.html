<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining POMDPs and MDPs · POMDPs.jl</title><meta name="title" content="Defining POMDPs and MDPs · POMDPs.jl"/><meta property="og:title" content="Defining POMDPs and MDPs · POMDPs.jl"/><meta property="twitter:title" content="Defining POMDPs and MDPs · POMDPs.jl"/><meta name="description" content="Documentation for POMDPs.jl."/><meta property="og:description" content="Documentation for POMDPs.jl."/><meta property="twitter:description" content="Documentation for POMDPs.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="POMDPs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">POMDPs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../">POMDPs.jl</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../get_started/">Getting Started</a></li><li><a class="tocitem" href="../concepts/">Concepts and Architecture</a></li></ul></li><li><span class="tocitem">Defining (PO)MDP Models</span><ul><li class="is-active"><a class="tocitem" href>Defining POMDPs and MDPs</a><ul class="internal"><li><a class="tocitem" href="#tiger"><span>A Basic Example: The Tiger POMDP</span></a></li><li><a class="tocitem" href="#Guide-to-Defining-POMDPs"><span>Guide to Defining POMDPs</span></a></li><li><a class="tocitem" href="#Other-ways-to-define-a-(PO)MDP"><span>Other ways to define a (PO)MDP</span></a></li></ul></li><li><a class="tocitem" href="../interfaces/">Spaces and Distributions</a></li></ul></li><li><span class="tocitem">Writing Solvers</span><ul><li><a class="tocitem" href="../def_solver/">Solvers</a></li><li><a class="tocitem" href="../offline_solver/">Example: Defining an offline solver</a></li><li><a class="tocitem" href="../online_solver/">Example: Defining an online solver</a></li></ul></li><li><span class="tocitem">Writing Belief Updaters</span><ul><li><a class="tocitem" href="../def_updater/">Defining a Belief Updater</a></li></ul></li><li><span class="tocitem">Analyzing Results</span><ul><li><a class="tocitem" href="../simulation/">Simulation Standard</a></li><li><a class="tocitem" href="../run_simulation/">Running Simulations</a></li><li><a class="tocitem" href="../policy_interaction/">Interacting with Policies</a></li></ul></li><li><span class="tocitem">Examples and Gallery</span><ul><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../example_defining_problems/">Defining a POMDP</a></li><li><a class="tocitem" href="../example_solvers/">Using Different Solvers</a></li><li><a class="tocitem" href="../example_simulations/">Simulations Examples</a></li><li><a class="tocitem" href="../example_gridworld_mdp/">GridWorld MDP Tutorial</a></li><li><a class="tocitem" href="../gallery/">Gallery of POMDPs.jl Problems</a></li></ul></li><li><span class="tocitem">POMDPTools</span><ul><li><a class="tocitem" href="../POMDPTools/">POMDPTools: the standard library for POMDPs.jl</a></li><li><a class="tocitem" href="../POMDPTools/distributions/">Implemented Distributions</a></li><li><a class="tocitem" href="../POMDPTools/model/">Model Tools</a></li><li><a class="tocitem" href="../POMDPTools/visualization/">Visualization</a></li><li><a class="tocitem" href="../POMDPTools/beliefs/">Implemented Belief Updaters</a></li><li><a class="tocitem" href="../POMDPTools/policies/">Implemented Policies</a></li><li><a class="tocitem" href="../POMDPTools/simulators/">Implemented Simulators</a></li><li><a class="tocitem" href="../POMDPTools/common_rl/">CommonRLInterface Integration</a></li><li><a class="tocitem" href="../POMDPTools/testing/">Testing</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions (FAQ)</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Defining (PO)MDP Models</a></li><li class="is-active"><a href>Defining POMDPs and MDPs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining POMDPs and MDPs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPOMDP/POMDPs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPOMDP/POMDPs.jl/blob/master/docs/src/def_pomdp.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="defining_pomdps"><a class="docs-heading-anchor" href="#defining_pomdps">Defining POMDPs and MDPs</a><a id="defining_pomdps-1"></a><a class="docs-heading-anchor-permalink" href="#defining_pomdps" title="Permalink"></a></h1><p>As described in the <a href="../concepts/#Concepts-and-Architecture">Concepts and Architecture</a> section, an MDP is defined by the state space, action space, transition distributions, reward function, and discount factor, <span>$(S,A,T,R,\gamma)$</span>. A POMDP also includes the observation space, and observation probability distributions, for a definition of <span>$(S,A,T,R,O,Z,\gamma)$</span>. A problem definition in POMDPs.jl consists of an implicit or explicit definition of each of these elements.</p><p>It is possible to define a (PO)MDP with a more traditional <a href="#Object-oriented">object-oriented approach</a> in which the user defines a new type to represent the (PO)MDP and methods of <a href="../api/#API-Documentation">interface functions</a> to define the tuple elements. However, the <a href="https://github.com/JuliaPOMDP/QuickPOMDPs.jl">QuickPOMDPs package</a> provides a more concise way to get started, using keyword arguments instead of new types and methods. Essentially each keyword argument defines a corresponding <a href="../api/#API-Documentation">POMDPs api function</a>. Since the important concepts are the same for the object oriented approach and the QuickPOMDP approach, we will use the latter for this discussion.</p><p>This guide has three parts: First, it explains a very simple example (the Tiger POMDP), then uses a more complex example to illustrate the broader capabilities of the interface. Finally, some alternative ways of defining (PO)MDPs are discussed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This guide assumes that you are comfortable programming in Julia, especially familiar with various ways of defining <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions"><em>anonymous functions</em></a>. Users should consult the <a href="https://docs.julialang.org">Julia documentation</a> to learn more about programming in Julia.</p></div></div><h2 id="tiger"><a class="docs-heading-anchor" href="#tiger">A Basic Example: The Tiger POMDP</a><a id="tiger-1"></a><a class="docs-heading-anchor-permalink" href="#tiger" title="Permalink"></a></h2><p>In the first section of this guide, we will explain a QuickPOMDP implementation of a very simple problem: the <a href="https://www.sciencedirect.com/science/article/pii/S000437029800023X">classic Tiger POMDP</a>. In the tiger POMDP, the agent is tasked with escaping from a room. There are two doors leading out of the room. Behind one of the doors is a tiger, and behind the other is sweet, sweet freedom. If the agent opens the door and finds the tiger, it gets eaten (and receives a reward of -100). If the agent opens the other door, it escapes and receives a reward of 10. The agent can also listen. Listening gives a noisy measurement of which door the tiger is hiding behind. Listening gives the agent the correct location of the tiger 85% of the time. The agent receives a reward of -1 for listening. The complete implementation looks like this:</p><pre><code class="language-julia hljs">using QuickPOMDPs: QuickPOMDP
using POMDPTools: Deterministic, Uniform, SparseCat

m = QuickPOMDP(
    states = [&quot;left&quot;, &quot;right&quot;],
    actions = [&quot;left&quot;, &quot;right&quot;, &quot;listen&quot;],
    observations = [&quot;left&quot;, &quot;right&quot;],
    discount = 0.95,

    transition = function (s, a)
        if a == &quot;listen&quot;
            return Deterministic(s) # tiger stays behind the same door
        else # a door is opened
            return Uniform([&quot;left&quot;, &quot;right&quot;]) # reset
        end
    end,

    observation = function (a, sp)
        if a == &quot;listen&quot;
            if sp == &quot;left&quot;
                return SparseCat([&quot;left&quot;, &quot;right&quot;], [0.85, 0.15]) # sparse categorical
            else
                return SparseCat([&quot;right&quot;, &quot;left&quot;], [0.85, 0.15])
            end
        else
            return Uniform([&quot;left&quot;, &quot;right&quot;])
        end
    end,

    reward = function (s, a)
        if a == &quot;listen&quot;
            return -1.0
        elseif s == a # the tiger was found
            return -100.0
        else # the tiger was escaped
            return 10.0
        end
    end,

    initialstate = Uniform([&quot;left&quot;, &quot;right&quot;]),
);</code></pre><p>The next sections explain how each of the elements of the POMDP tuple are defined in this implementation:</p><h4 id="State,-action-and-observation-spaces"><a class="docs-heading-anchor" href="#State,-action-and-observation-spaces">State, action and observation spaces</a><a id="State,-action-and-observation-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#State,-action-and-observation-spaces" title="Permalink"></a></h4><p>In this example, each state, action, and observation is a <code>String</code>. The state, action and observation spaces (<span>$S$</span>, <span>$A$</span>, and <span>$O$</span>), are defined with the <code>states</code>, <code>actions</code> and <code>observations</code> keyword arguments. In this case, they are simply <code>Vector</code>s containing all the elements in the space.</p><h4 id="Transition-and-observation-distributions"><a class="docs-heading-anchor" href="#Transition-and-observation-distributions">Transition and observation distributions</a><a id="Transition-and-observation-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-and-observation-distributions" title="Permalink"></a></h4><p>The <code>transition</code> and <code>observation</code> keyword arguments are used to define the transition distribution, <span>$T$</span>, and observation distribution, <span>$Z$</span>, respectively. These models are defined using functions that return <a href="#Commonly-used-distributions"><em>distribution objects</em> (more info below)</a>. The transition function takes state and action arguments and returns a distribution of the resulting next state. The observation function takes in an action and the resulting next state (<code>sp</code>, short for &quot;s prime&quot;) and returns the distribution of the observation emitted at this state.</p><h4 id="Reward-function"><a class="docs-heading-anchor" href="#Reward-function">Reward function</a><a id="Reward-function-1"></a><a class="docs-heading-anchor-permalink" href="#Reward-function" title="Permalink"></a></h4><p>The <code>reward</code> keyword argument defines <span>$R$</span>. It is a function that takes in a state and action and returns a number.</p><h4 id="Discount-and-initial-state-distribution"><a class="docs-heading-anchor" href="#Discount-and-initial-state-distribution">Discount and initial state distribution</a><a id="Discount-and-initial-state-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Discount-and-initial-state-distribution" title="Permalink"></a></h4><p>The discount factor, <span>$\gamma$</span>, is defined with the <code>discount</code> keyword, and is simply a number between 0 and 1. The initial state distribution, <code>b_0</code>, is defined with the <code>initialstate</code> argument, and is a <a href="#Commonly-used-distributions">distribution object</a>.</p><p>The example above shows a complete implementation of a very simple discrete-space POMDP. However, POMDPs.jl is capable of concisely expressing much more complex models with continuous and hybrid spaces. The guide below introduces a more complex example to fully explain the ways that a POMDP can be defined.</p><h2 id="Guide-to-Defining-POMDPs"><a class="docs-heading-anchor" href="#Guide-to-Defining-POMDPs">Guide to Defining POMDPs</a><a id="Guide-to-Defining-POMDPs-1"></a><a class="docs-heading-anchor-permalink" href="#Guide-to-Defining-POMDPs" title="Permalink"></a></h2><h3 id="po-mountaincar"><a class="docs-heading-anchor" href="#po-mountaincar">A more complex example: A partially-observable mountain car</a><a id="po-mountaincar-1"></a><a class="docs-heading-anchor-permalink" href="#po-mountaincar" title="Permalink"></a></h3><p><a href="https://en.wikipedia.org/wiki/Mountain_car_problem">Mountain car</a> is a classic problem in reinforcement learning. A car starts in a valley between two hills, and must reach the goal at the top of the hill to the right (<a href="https://en.wikipedia.org/wiki/Mountain_car_problem">see wikipedia for image</a>). The actions are left and right acceleration and neutral and the state consists of the car&#39;s position and velocity. In this partially-observable version, there is a small amount of acceleration noise and observations are normally-distributed noisy measurements of the position. This problem can be implemented as follows:</p><pre><code class="language-julia hljs">import QuickPOMDPs: QuickPOMDP
import POMDPTools: ImplicitDistribution
import Distributions: Normal

mountaincar = QuickPOMDP(
    actions = [-1., 0., 1.],
    obstype = Float64,
    discount = 0.95,

    transition = function (s, a)        
        ImplicitDistribution() do rng
            x, v = s
            vp = v + a*0.001 + cos(3*x)*-0.0025 + 0.0002*randn(rng)
            vp = clamp(vp, -0.07, 0.07)
            xp = x + vp
            return (xp, vp)
        end
    end,

    observation = (a, sp) -&gt; Normal(sp[1], 0.15),

    reward = function (s, a, sp)
        if sp[1] &gt; 0.5
            return 100.0
        else
            return -1.0
        end
    end,

    initialstate = ImplicitDistribution(rng -&gt; (-0.2*rand(rng), 0.0)),
    isterminal = s -&gt; s[1] &gt; 0.5
)</code></pre><p>The following sections provide a detailed guide to defining the components of a POMDP using this example and the <a href="#tiger">tiger pomdp</a> further above.</p><h3 id="space_representation"><a class="docs-heading-anchor" href="#space_representation">State, action, and observation spaces</a><a id="space_representation-1"></a><a class="docs-heading-anchor-permalink" href="#space_representation" title="Permalink"></a></h3><p>In POMDPs.jl, a state, action, or observation can be represented by any Julia object, for example an integer, a floating point number, a string or <code>Symbol</code>, or a vector. For example, in the tiger problem, the states are <code>String</code>s, and in the mountaincar problem, the state is a <code>Tuple</code> of two floating point numbers, and the actions and observations are floating point numbers. These types are usually inferred from the space or initial state distribution definitions.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Objects representing individual states, actions, and observations should not be altered once they are created, since they may be used as dictionary keys or stored in histories. Hence it is usually best to use immutable objects such as integers or <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArray</code>s</a>. If the states need to be mutable (e.g. aggregate types with vectors in them), make sure the states are not actualy mutated and that <code>hash</code> and <code>==</code> functions are implmemented (see <a href="https://github.com/andrewcooke/AutoHashEquals.jl"><code>AutoHashEquals</code></a>)</p></div></div><p>The state, action, and observation spaces are defined with the <code>states</code>, <code>actions</code>, and <code>observations</code> Quick(PO)MDP keyword arguments. The simplest way to define these spaces is with a <code>Vector</code> of states, e.g. <code>states = [&quot;left&quot;, &quot;right&quot;]</code> in the tiger problem. More complicated spaces, such as vector spaces and other continuous, uncountable, or hybrid sets can be defined with custom objects that adhere to the <a href="../interfaces/#space-interface">space interface</a>. However it should be noted that, for many solvers, <em>an explicit enumeration of the state and observation spaces is not needed</em>. Instead, it is sufficient to specify the state or observation <em>type</em> using the <code>statetype</code> or <code>obstype</code> arguments, e.g. <code>obstype = Float64</code> in the mountaincar problem.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you are having a difficult time representing the state or observation space, it is likely that you will not be able to use a solver that requires an explicit representation. It is usually best to omit that space from the definition and try solvers to see if they work.</p></div></div><h4 id="state-dep-action"><a class="docs-heading-anchor" href="#state-dep-action">State- or belief-dependent action spaces</a><a id="state-dep-action-1"></a><a class="docs-heading-anchor-permalink" href="#state-dep-action" title="Permalink"></a></h4><p>In some problems, the set of allowable actions depends on the state or belief. This can be implemented by providing a function of the state or belief to the <code>actions</code> argument, e.g. if you can only take the action <code>1</code> in state <code>1</code>, but can take full action space <code>1</code>, <code>2</code> and <code>3</code>, in an MDP, you might use</p><pre><code class="language-julia hljs"># add default vlaue &quot;s = nothing&quot; , &quot;actions(mdp)&quot; won&#39;t throw error.
actions = function (s = nothing) 
    if s == 1
        return [1]      #&lt;--- return state-dep-actions
    else
        return [1,2,3]  #&lt;--- return full action space here
    end
end</code></pre><p>Similarly, in a POMDP, you may wish to only allow action <code>1</code> if the belief <code>b</code> assigns a nonzero probability to state <code>1</code>. This can be accomplished with</p><pre><code class="language-julia hljs">actions = function (b)
    if pdf(b, 1) &gt; 0.0
        return [1,2,3]
    else
        return [2,3]
    end
end</code></pre><h3 id="Transition-and-observation-distributions-2"><a class="docs-heading-anchor" href="#Transition-and-observation-distributions-2">Transition and observation distributions</a><a class="docs-heading-anchor-permalink" href="#Transition-and-observation-distributions-2" title="Permalink"></a></h3><p>The transition and observation observation distributions are specified through <em>functions that return distributions</em>. A distribution object implements parts of the <a href="../interfaces/#Distributions">distribution interface</a>, most importantly a <a href="../api/#Base.rand"><code>rand</code></a> function that provides a way to sample the distribution and, for explicit distributions, a <a href="../api/#Distributions.pdf"><code>pdf</code></a> function that evaluates the probability mass or density of a given outcome. In most simple cases, you will be able to use a pre-defined distribution like the ones listed below, but occasionally you will define your own for more complex problems.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Since the <code>transition</code> and <code>observation</code> functions return distributions, you should not call <code>rand</code> within these functions (unless it is within an <a href="#implicit_distribution_section"><code>ImplicitDistribution</code></a> sampling function (see below)).</p></div></div><p>The <code>transition</code> function takes in a state <code>s</code> and action <code>a</code> and returns a distribution object that defines the distribution of next states given that the current state is <code>s</code> and the action is <code>a</code>, that is <span>$T(s&#39; | s, a)$</span>. Similarly the <code>observation</code> function takes in the action <code>a</code> and the next state <code>sp</code> and returns a distribution object defining <span>$O(z | a, s&#39;)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is also possible to define the <code>observation</code> function in terms of the previous state <code>s</code>, along with <code>a</code>, and <code>sp</code>. This is necessary, for example, when the observation is a measurement of change in state, e.g. <code>sp - s</code>. However some solvers may use the <code>a, sp</code> method (and hence cannot solve problems where the observation is conditioned on <span>$s$</span> and <span>$s&#39;$</span>). Since providing an <code>a, sp</code> method <em>automatically</em> defines the <code>s, a, sp</code> method, problem writers should usually define only the <code>a, sp</code> method, and only define the <code>s, a, sp</code> method if it is necessary. Except for special performance cases, problem writers should <em>never</em> need to define both methods.</p></div></div><h4 id="Commonly-used-distributions"><a class="docs-heading-anchor" href="#Commonly-used-distributions">Commonly-used distributions</a><a id="Commonly-used-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Commonly-used-distributions" title="Permalink"></a></h4><p>In most cases, the following pre-defined distributions found in the <a href="../POMDPTools/#pomdptools_section">POMDPTools</a> and <a href="https://github.com/JuliaStats/Distributions.jl">Distributions</a> packages will be sufficient to define models.</p><h5 id="Deterministic"><a class="docs-heading-anchor" href="#Deterministic"><code>Deterministic</code></a><a id="Deterministic-1"></a><a class="docs-heading-anchor-permalink" href="#Deterministic" title="Permalink"></a></h5><p>The <code>Deterministic</code> distribution should be used when there is no randomness in the state or observation given the state and action inputs. This commonly occurs when the new state is a deterministic function of the state and action or the state stays the same, for example when the action is <code>&quot;listen&quot;</code> in the <a href="#tiger">tiger example</a> above, the transition function returns <code>Deterministic(s)</code>.</p><h5 id="SparseCat"><a class="docs-heading-anchor" href="#SparseCat"><code>SparseCat</code></a><a id="SparseCat-1"></a><a class="docs-heading-anchor-permalink" href="#SparseCat" title="Permalink"></a></h5><p>In discrete POMDPs, it is common for the state or observation to have a few possible outcomes with specified probabilities. This can be represented with a sparse categorical <code>SparseCat</code> distribution that takes a list of outcomes and a list of associated probabilities as arguments. For instance, in the tiger example above, when the action is <code>&quot;listen&quot;</code>, there is an 85% chance of receiving the correct observation. Thus if the state is <code>&quot;left&quot;</code>, the observation distribution is <code>SparseCat([&quot;left&quot;, &quot;right&quot;], [0.85, 0.15])</code>, and <code>SparseCat([&quot;right&quot;, &quot;left&quot;], [0.85, 0.15])</code> if the state is <code>&quot;right&quot;</code>.</p><p>Another example where <code>SparseCat</code> distributions are useful is in grid-world problems, where there is a high probability of transitioning along the direction of the action, a low probability of transitioning to other adjacent states, and zero probability of transitioning to any other states.</p><h5 id="Uniform"><a class="docs-heading-anchor" href="#Uniform"><code>Uniform</code></a><a id="Uniform-1"></a><a class="docs-heading-anchor-permalink" href="#Uniform" title="Permalink"></a></h5><p>Another common case is a uniform distribution over a space or set of outcomes. This can be represented with a <code>Uniform</code> object that takes a set of outcomes as an argument. For example, the initial state distribution in the tiger problem is represented with <code>Uniform([&quot;left&quot;, &quot;right&quot;])</code> indicating that both states are equally likely.</p><h5 id="Distributions.jl"><a class="docs-heading-anchor" href="#Distributions.jl">Distributions.jl</a><a id="Distributions.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Distributions.jl" title="Permalink"></a></h5><p>If the states or observations have numerical or vector values, the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl package</a> provides a suite of suitable distributions. For example, the observation function in the <a href="#po-mountaincar">partially-observable mountain car example above</a>,</p><pre><code class="language-julia hljs">observation = (a, sp) -&gt; Normal(sp[1], 0.15)</code></pre><p>returns a <code>Normal</code> distribution from this package with a mean that depends on the car&#39;s location (the first element of state <code>sp</code>) and a standard deviation of 0.15.</p><h5 id="implicit_distribution_section"><a class="docs-heading-anchor" href="#implicit_distribution_section"><code>ImplicitDistribution</code></a><a id="implicit_distribution_section-1"></a><a class="docs-heading-anchor-permalink" href="#implicit_distribution_section" title="Permalink"></a></h5><p>In many cases, especially when the state or observation spaces are continuous or hybrid, it is difficult or impossible to specify the probability density explicitly. Fortunately, many solvers for these problems do not require explicit density information and instead need only samples from the distribution. In this case, an &quot;implicit distribution&quot; or &quot;generative model&quot; is sufficient. In POMDPs.jl, this can be represented using an <a href="../POMDPTools/distributions/#POMDPTools.POMDPDistributions.ImplicitDistribution"><code>ImplicitDistribution</code></a> object.</p><p>The argument to an <code>ImplicitDistribution</code> constructor is a function that takes a random number generator as an argument and returns a sample from the distribution. To see how this works, we&#39;ll look at an example inspired by the <a href="#po-mountaincar">mountaincar</a> initial state distribution. Samples from this distribution are position-velocity tuples where the velocity is always zero, but the position is uniformly distributed between -0.2 and 0. Consider the following code:</p><pre><code class="language-julia hljs">using StableRNGs: StableRNG
using POMDPTools: ImplicitDistribution

rng = StableRNG(1)

d = ImplicitDistribution(rng -&gt; (-0.2*rand(rng), 0.0))
rand(rng, d)
# output
(-0.11703892844248372, 0.0)</code></pre><p>Here, <code>rng</code> is the random number generator. When <code>rand(rng, d)</code> is called, the sampling function, <code>rng -&gt; (-0.2*rand(rng), 0.0)</code>, is called to generate a state.  The sampling function uses <code>rng</code> to generate a random number between 0 and 1 (<code>rand(rng)</code>), multiplies it by -0.2 to get the position, and creates a tuple with the position and a velocity of <code>0.0</code> and returns an initial state that might be, for instance <code>(-0.11, 0.0)</code>. Any time that a solver, belief updater, or simulator needs an initial state for the problem, it will be sampled in this way.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The random number generator is a subtype of <code>AbstractRNG</code>. It is important to use this random number generator for all calls to <code>rand</code> in the sample function for reproducible results. Moreover some solvers use specialized random number generators that allow them to reduce variance. See also the <a href="../faq/#What-if-I-don&#39;t-use-the-rng-argument?">What if I don&#39;t use the <code>rng</code> argument?</a> FAQ.</p></div></div><p>It is also common to use Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/functions/#Do-Block-Syntax-for-Function-Arguments"><code>do</code> block syntax</a> to define more complex sampling functions. For instance the transition function in the mountaincar example returns an <a href="#implicit_distribution_section"><code>ImplicitDistribution</code></a> with a sampling function that (1) generates a new noisy velocity through a <code>randn</code> call, then (2) clamps the velocity, and finally (3) integrates the position with Euler&#39;s method:</p><pre><code class="language-julia hljs">transition = function (s, a)        
    ImplicitDistribution() do rng
        x, v = s
        vp = v + a*0.001 + cos(3*x)*-0.0025 + 0.0002*randn(rng)
        vp = clamp(vp, -0.07, 0.07)
        xp = x + vp
        return (xp, vp)
    end
end</code></pre><p>Because of the nonlinear clamp operation, it would be difficult to represent this distribution explicitly.</p><h5 id="Custom-distributions"><a class="docs-heading-anchor" href="#Custom-distributions">Custom distributions</a><a id="Custom-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-distributions" title="Permalink"></a></h5><p>If none of the distributions above are suitable, for example if you need to represent an explicit distribution with hybrid support, it is not difficult to define your own distributions by implementing the functions in the <a href="../interfaces/#Distributions">distribution interface</a>.</p><h3 id="Reward-functions"><a class="docs-heading-anchor" href="#Reward-functions">Reward functions</a><a id="Reward-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Reward-functions" title="Permalink"></a></h3><p>The reward function maps a combination of state, action, and observation arguments to the reward for a step. For instance, the reward function in the mountaincar problem,</p><pre><code class="language-julia hljs">reward = function (s, a, sp)
    if sp[1] &gt; 0.5
        return 100.0
    else
        return -1.0
    end
end</code></pre><p>takes in the previous state, <code>s</code>, the action, <code>a</code>, and the resulting state, <code>sp</code> and returns a large positive reward if the resulting position, <code>sp[1]</code>, is beyond a threshold (note the coupling of the terminal reward) and a small negative reward on all other steps. If the reward in the problem is stochastic, the <code>reward</code> function implemented in POMDPs.jl should return the mean reward.</p><p>There are two possible reward function argument signatures that a problem-writer might consider implementing for an MDP: <code>(s, a)</code> and <code>(s, a, sp)</code>. For a POMDP, there is an additional version, <code>(s, a, sp, o)</code>. The <code>(s, a, sp)</code> version is useful when transition to a terminal state results in a reward, and the <code>(s, a, sp, o)</code> version is useful for cases when the reward is associated with an observation, such as a negative reward for the stress caused by a medical diagnostic test that indicates the possibility of a disease. <strong>Problem writers should implement the version with the fewest number of arguments possible</strong>, since the versions with more arguments are automatically provided to solvers and simulators if a version with fewer arguments is implemented.</p><p>In rare cases, it may make sense to implement two or more versions of the function, for example if a solver requires <code>(s, a)</code>, but the user wants an observation-dependent reward to show up in simulation. It is OK to implement two methods of the reward function as long as the following relationships hold: <span>$R(s, a) = E_{s&#39;\sim T(s&#39;|s,a)}[R(s, a, s&#39;)]$</span> and <span>$R(s, a, s&#39;) = E_{o \sim Z(o | s, a, s&#39;)}[R(s, a, s&#39;, o)]$</span>. That is, the versions with fewer arguments <em>must</em> be expectations of versions with more arguments.</p><h3 id="Other-Components"><a class="docs-heading-anchor" href="#Other-Components">Other Components</a><a id="Other-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Components" title="Permalink"></a></h3><h4 id="Discount-factors"><a class="docs-heading-anchor" href="#Discount-factors">Discount factors</a><a id="Discount-factors-1"></a><a class="docs-heading-anchor-permalink" href="#Discount-factors" title="Permalink"></a></h4><p>The <code>discount</code> keyword argument is simply a number between 0 and 1 used to discount rewards in the future.</p><h4 id="Initial-state-distribution"><a class="docs-heading-anchor" href="#Initial-state-distribution">Initial state distribution</a><a id="Initial-state-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-state-distribution" title="Permalink"></a></h4><p>The <code>initialstate</code> argument should be a distribution object (see <a href="#Commonly-used-distributions">above</a>) that defines the initial state distribution (and initial belief for POMDPs).</p><h4 id="Terminal-states"><a class="docs-heading-anchor" href="#Terminal-states">Terminal states</a><a id="Terminal-states-1"></a><a class="docs-heading-anchor-permalink" href="#Terminal-states" title="Permalink"></a></h4><p>The function supplied to the <code>isterminal</code> object defines which which states in the POMDP are terminal. The function should take a state as an argument as an argument and return <code>true</code> if the state is terminal and <code>false</code> otherwise. For example, in the mountaincar example above, <code>isterminal = s -&gt; s[1] &gt; 0.5</code> indicates all states where the position, <code>s[1]</code> is greater than 0.5 are terminal.</p><p>It is assumed that the system will take no further steps once it has reached a terminal state. Since reward is assigned for taking steps, no additional award can be accumulated from a terminal state. Consequently, the most important property of terminal states is that <em>the value of a terminal state is always zero</em>. Many solvers leverage this property for efficiency. As in the mountaincar example</p><h2 id="Other-ways-to-define-a-(PO)MDP"><a class="docs-heading-anchor" href="#Other-ways-to-define-a-(PO)MDP">Other ways to define a (PO)MDP</a><a id="Other-ways-to-define-a-(PO)MDP-1"></a><a class="docs-heading-anchor-permalink" href="#Other-ways-to-define-a-(PO)MDP" title="Permalink"></a></h2><p>Besides the Quick(PO)MDP approach above, there are several alternative ways to define (PO)MDP models:</p><h3 id="Object-oriented"><a class="docs-heading-anchor" href="#Object-oriented">Object-oriented</a><a id="Object-oriented-1"></a><a class="docs-heading-anchor-permalink" href="#Object-oriented" title="Permalink"></a></h3><p>First, it is possible to create your own (PO)MDP types and implement the components of the POMDP directly as methods of <a href="../api/#API-Documentation">POMDPs.jl interface functions</a>. This approach can be thought of as the &quot;low-level&quot; way to define a POMDP, and the QuickPOMDP as merely a syntactic convenience. There are a few things that make this object-oriented approach more cumbersome than the QuickPOMDP approach, but the structure is similar. For example, the <a href="#tiger">tiger</a> QuickPOMDP shown above can be implemented as follows:</p><pre><code class="language-julia hljs">import POMDPs
using POMDPs: POMDP
using POMDPTools: Deterministic, Uniform, SparseCat

struct TigerPOMDP &lt;: POMDP{String, String, String}
    p_correct::Float64
    indices::Dict{String, Int}

    TigerPOMDP(p_correct=0.85) = new(p_correct, Dict(&quot;left&quot;=&gt;1, &quot;right&quot;=&gt;2, &quot;listen&quot;=&gt;3))
end

POMDPs.states(m::TigerPOMDP) = [&quot;left&quot;, &quot;right&quot;]
POMDPs.actions(m::TigerPOMDP) = [&quot;left&quot;, &quot;right&quot;, &quot;listen&quot;]
POMDPs.observations(m::TigerPOMDP) = [&quot;left&quot;, &quot;right&quot;]
POMDPs.discount(m::TigerPOMDP) = 0.95
POMDPs.stateindex(m::TigerPOMDP, s) = m.indices[s]
POMDPs.actionindex(m::TigerPOMDP, a) = m.indices[a]
POMDPs.obsindex(m::TigerPOMDP, o) = m.indices[o]

function POMDPs.transition(m::TigerPOMDP, s, a)
    if a == &quot;listen&quot;
        return Deterministic(s) # tiger stays behind the same door
    else # a door is opened
        return Uniform([&quot;left&quot;, &quot;right&quot;]) # reset
    end
end

function POMDPs.observation(m::TigerPOMDP, a, sp)
    if a == &quot;listen&quot;
        if sp == &quot;left&quot;
            return SparseCat([&quot;left&quot;, &quot;right&quot;], [m.p_correct, 1.0-m.p_correct])
        else
            return SparseCat([&quot;right&quot;, &quot;left&quot;], [m.p_correct, 1.0-m.p_correct])
        end
    else
        return Uniform([&quot;left&quot;, &quot;right&quot;])
    end
end

function POMDPs.reward(m::TigerPOMDP, s, a)
    if a == &quot;listen&quot;
        return -1.0
    elseif s == a # the tiger was found
        return -100.0
    else # the tiger was escaped
        return 10.0
    end
end

POMDPs.initialstate(m::TigerPOMDP) = Uniform([&quot;left&quot;, &quot;right&quot;])
# output</code></pre><p>It is easy to see that the new methods are similar to the keyword arguments in the QuickPOMDP approach, except that every function has an initial <code>m</code> argument that has the newly created POMDP type. There are several differences from the QuickPOMDP approach: First, the POMDP is represented by a new <code>struct</code> that is a subtype of <code>POMDP{S,A,O}</code>. The state, action, and observation types must be specified as the <code>S</code>, <code>A</code>, and <code>O</code> parameters of the <a href="../api/#POMDPs.POMDP"><code>POMDP</code></a> abstract type. Second, this new <code>struct</code> may contain problem-specific fields, which makes it easy for others to construct POMDPs that have the same structure but different parameters. For example, in the code above, the <code>struct</code> has a <code>p_correct</code> parameter that specifies the probability of receiving a correct observation when the &quot;listen&quot; action is taken. The final and most cumbersome difference between this object-oriented approach and using QuickPOMDPs is that the user must implement <a href="../api/#POMDPs.stateindex"><code>stateindex</code></a>, <a href="../api/#POMDPs.actionindex"><code>actionindex</code></a>, and <a href="../api/#POMDPs.obsindex"><code>obsindex</code></a> to map states, actions, and observations to appropriate indices so that data such as values can be stored and accessed efficiently in vectors.</p><h3 id="Using-a-single-generative-function-instead-of-separate-T,-Z,-and-R"><a class="docs-heading-anchor" href="#Using-a-single-generative-function-instead-of-separate-T,-Z,-and-R">Using a single generative function instead of separate <span>$T$</span>, <span>$Z$</span>, and <span>$R$</span></a><a id="Using-a-single-generative-function-instead-of-separate-T,-Z,-and-R-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-single-generative-function-instead-of-separate-T,-Z,-and-R" title="Permalink"></a></h3><p>In some cases, you may wish to use a simulator that generates the next state, observation, and/or reward (<span>$s&#39;$</span>, <span>$o$</span>, and <span>$r$</span>) simultaneously. This is sometimes called a &quot;generative model&quot;.</p><p>For example if you are working on an autonomous driving POMDP, the car may travel for one or more seconds in between POMDP decision steps during which it may accumulate reward and observation measurements. In this case it might be very difficult to create a <a href="../api/#POMDPs.reward"><code>reward</code></a> or <a href="../api/#POMDPs.observation"><code>observation</code></a> function based on <span>$s$</span>, <span>$a$</span>, and <span>$s&#39;$</span> arguments.</p><p>For situations like this, <code>gen</code> is an alternative to <code>transition</code>, <code>observation</code>, and <code>reward</code>. The <code>gen</code> function should take in state, action, and random number generator arguments and return a <a href="https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types"><code>NamedTuple</code></a> with keys <code>sp</code> (for &quot;s-prime&quot;, the next state), <code>o</code>, and <code>r</code>. The <a href="#po-mountaincar">mountaincar example above</a> can be implemented with <code>gen</code> as shown below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>gen</code> is intended <em>only</em> for the case where <em>two or more</em> of the next state, observation, and reward need to be generated at the same time. If the state transition model can be separated from the reward and observation models, you should implement <code>transition</code> with an <a href="#implicit_distribution_section"><code>ImplicitDistribution</code></a> instead of <code>gen</code>. See also the &quot;<a href="../faq/#What-is-the-difference-between-transition,-gen,-and-@gen?">What is the difference between <code>transition</code>, <code>gen</code>, and <code>@gen</code>?</a>&quot; FAQ.</p></div></div><pre><code class="language-julia hljs">using QuickPOMDPs: QuickPOMDP
using POMDPTools: ImplicitDistribution

mountaincar = QuickPOMDP(
    actions = [-1., 0., 1.],
    obstype = Float64,
    discount = 0.95,

    gen = function (s, a, rng)
        x, v = s
        vp = v + a*0.001 + cos(3*x)*-0.0025 + 0.0002*randn(rng)
        vp = clamp(vp, -0.07, 0.07)
        xp = x + vp
        if xp &gt; 0.5
            r = 100.0
        else
            r = -1.0
        end
        o = xp + 0.15*randn(rng)
        return (sp=(xp, vp), o=o, r=r)
    end,

    initialstate = ImplicitDistribution(rng -&gt; (-0.2*rand(rng), 0.0)),
    isterminal = s -&gt; s[1] &gt; 0.5
)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>gen</code> is not tied to the QuickPOMDP approach; it can also be used in the object-oriented paradigm.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is possible to mix and match <code>gen</code> with <code>transtion</code>, <code>observation</code>, and <code>reward</code>. For example, if the <code>gen</code> function returns a <code>NamedTuple</code> with <code>sp</code> and <code>r</code> keys, POMDPs.jl will try to use <code>gen</code> to generate states and rewards and the <code>observation</code> function to generate observations.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Implementing <code>gen</code> instead of <code>transition</code>, <code>observation</code>, and <code>reward</code> will limit which solvers you can use; for example, it is impossible to use a solver that requires an explicit transition distribution</p></div></div><h3 id="Tabular"><a class="docs-heading-anchor" href="#Tabular">Tabular</a><a id="Tabular-1"></a><a class="docs-heading-anchor-permalink" href="#Tabular" title="Permalink"></a></h3><p>Finally, it is sometimes convenient to define (PO)MDPs with tables that define the transition and observation probabilities and rewards. In this case, the states, actions, and observations must simply be integers.</p><p>The code below is a tabular implementation of the <a href="#tiger">tiger example</a> with the states, actions, and observations mapped to the following integers:</p><table><tr><th style="text-align: right">integer</th><th style="text-align: right">state, action, or observation</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">&quot;left&quot;</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">&quot;right&quot;</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right">&quot;listen&quot;</td></tr></table><pre><code class="language-julia hljs">using POMDPModels: TabularPOMDP

T = zeros(2,3,2)
T[:,:,1] = [1. 0.5 0.5; 
            0. 0.5 0.5]
T[:,:,2] = [0. 0.5 0.5; 
            1. 0.5 0.5]

O = zeros(2,3,2)
O[:,:,1] = [0.85 0.5 0.5; 
            0.15 0.5 0.5]
O[:,:,2] = [0.15 0.5 0.5; 
            0.85 0.5 0.5]

R = [-1. -100. 10.; 
     -1. 10. -100.]

m = TabularPOMDP(T, R, O, 0.95)</code></pre><p>Here <code>T</code> is a <span>$|S| \times |A| \times |S|$</span> array representing the transition probabilities, with <code>T[sp, a, s]</code> <span>$= T(s&#39; | s, a)$</span>. Similarly, <code>O</code> is an <span>$|O| \times |A| \times |S|$</span> encoding the observation distribution with <code>O[o, a, sp]</code> <span>$= Z(o | a, s&#39;)$</span>, and <code>R</code> is a <span>$|S| \times |A|$</span> matrix that encodes the reward function. 0.95 is the discount factor.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/">« Concepts and Architecture</a><a class="docs-footer-nextpage" href="../interfaces/">Spaces and Distributions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 9 February 2025 23:42">Sunday 9 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
