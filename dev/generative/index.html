<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative (PO)MDP Interface · POMDPs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="POMDPs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">POMDPs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../">POMDPs.jl</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../get_started/">Getting Started</a></li><li><a class="tocitem" href="../concepts/">Concepts and Architecture</a></li></ul></li><li><span class="tocitem">Defining (PO)MDP Models</span><ul><li><a class="tocitem" href="../def_pomdp/">Defining POMDPs and MDPs</a></li><li><a class="tocitem" href="../ddns/">Dynamic Decision Networks</a></li><li><a class="tocitem" href="../basic_properties/">Defining Basic (PO)MDP Properties</a></li><li><a class="tocitem" href="../explicit/">Explicit (PO)MDP Interface</a></li><li class="is-active"><a class="tocitem" href>Generative (PO)MDP Interface</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start-1"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Interface-Description-1"><span>Interface Description</span></a></li><li><a class="tocitem" href="#The-[gen](@ref)-function-1"><span>The <code>gen</code> function</span></a></li><li><a class="tocitem" href="#Examples-1"><span>Examples</span></a></li><li><a class="tocitem" href="#Random-number-generators-1"><span>Random number generators</span></a></li><li><a class="tocitem" href="#Performance-considerations-1"><span>Performance considerations</span></a></li></ul></li><li><a class="tocitem" href="../interfaces/">Spaces and Distributions</a></li><li><a class="tocitem" href="../requirements/">Interface Requirements for Problems</a></li></ul></li><li><span class="tocitem">Writing Solvers and Updaters</span><ul><li><a class="tocitem" href="../def_solver/">Defining a Solver</a></li><li><a class="tocitem" href="../specifying_requirements/">Specifying Requirements</a></li><li><a class="tocitem" href="../def_updater/">Defining a Belief Updater</a></li></ul></li><li><span class="tocitem">Analyzing Results</span><ul><li><a class="tocitem" href="../simulation/">Simulation Standard</a></li><li><a class="tocitem" href="../run_simulation/">Running Simulations</a></li><li><a class="tocitem" href="../policy_interaction/">Interacting with Policies</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions (FAQ)</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Defining (PO)MDP Models</a></li><li class="is-active"><a href>Generative (PO)MDP Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generative (PO)MDP Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPOMDP/POMDPs.jl/blob/master/docs/src/generative.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="generative_doc-1"><a class="docs-heading-anchor" href="#generative_doc-1">Generative (PO)MDP Interface</a><a class="docs-heading-anchor-permalink" href="#generative_doc-1" title="Permalink"></a></h1><h2 id="Quick-Start-1"><a class="docs-heading-anchor" href="#Quick-Start-1">Quick Start</a><a class="docs-heading-anchor-permalink" href="#Quick-Start-1" title="Permalink"></a></h2><p>A generative model for most (PO)MDPs can be completely defined with one function:</p><pre><code class="language-julia">function POMDPs.gen(m::YourPOMDPType, s, a, rng)
    # do dynamics/transition calculations here
    return (sp= #=new state=#, r= #=reward=#, o= #=observation=#)
end</code></pre><p>(<code>o</code> is not needed for MDPs.)</p><h2 id="Interface-Description-1"><a class="docs-heading-anchor" href="#Interface-Description-1">Interface Description</a><a class="docs-heading-anchor-permalink" href="#Interface-Description-1" title="Permalink"></a></h2><p>The <em>generative</em> interface consists of two functions:</p><ul><li><a href="../api/#POMDPs.gen"><code>gen</code></a> returns samples (e.g. states, observations and rewards) from a generative POMDP model.</li><li><a href="../api/#POMDPs.initialstate"><code>initialstate</code></a> returns a sampled initial state.</li></ul><p>The generative interface is typically used when it is easier to return sampled states and observations rather than explicit distributions as in the <a href="../explicit/#explicit_doc-1">Explicit interface</a>. This type of model is often referred to as a &quot;black-box&quot; model.</p><p>In some special cases (e.g. reinforcement learning with <a href="https://github.com/JuliaPOMDP/RLInterface.jl">RLInterface.jl</a>), an initial observation is needed before any actions are taken. In this case, the <a href="../api/#POMDPs.initialobs"><code>initialobs</code></a> function will be used.</p><h2 id="The-[gen](@ref)-function-1"><a class="docs-heading-anchor" href="#The-[gen](@ref)-function-1">The <a href="../api/#POMDPs.gen"><code>gen</code></a> function</a><a class="docs-heading-anchor-permalink" href="#The-[gen](@ref)-function-1" title="Permalink"></a></h2><p>The <a href="../api/#POMDPs.gen"><code>gen</code></a> function has three versions differentiated by the type of the first argument.</p><ul><li><p><code>gen(m::Union{POMDP, MDP}, s, a, rng)</code> provides a way to implement a generative model for an entire (PO)MDP in a single function. It should return values for a subset of <a href="../ddns/#Dynamic-Decision-Networks-1">the DDN Nodes</a> as a <code>NamedTuple</code>.</p><ul><li>This is typically the quickest and easiest way to implement a new POMDP model or wrap an existing simulator.</li><li>Example (defined by a problem writer): <code>gen(m::MyPOMDP, s, a, rng) = (sp=s+a, r=s^2, o=s+a+randn(rng))</code></li><li>This version should <strong>never</strong> be called by a solver or simulator, since there is no guarantee of which values will be present in the returned object.</li><li>Values for DDN nodes not present in the returned <code>NamedTuple</code> will be generated in the normal way with <code>gen(::DDNNode, ...)</code> or an explicit representation.</li></ul></li><li><p><code>gen(::</code><a href="../api/#POMDPs.DDNNode"><code>DDNNode</code></a><code>{nodename}, m, parent_values..., rng)</code> defines the generative model for a <strong>single <a href="../ddns/#Dynamic-Decision-Networks-1">DDN node</a></strong>. Together, a group of these functions can define a problem.</p><ul><li>Example (defined by a problem writer): <code>gen(::DDNNode{:o}, m::MyPOMDP, s, a, sp, rng) = sp + randn(rng)</code></li><li>Solver writers should only directly call this version in very rare cases when it needs to access to values for a particular node of the DDN generated by specific values of its parent nodes.</li></ul></li><li><p><code>gen(::</code><a href="../api/#POMDPs.DDNOut"><code>DDNOut</code></a><code>{nodenames}, m, s, a, rng)</code> returns a value or tuple of values for a subset of nodes in the <a href="../ddns/#Dynamic-Decision-Networks-1">DDN</a>. The arguments are values for the <strong>input nodes</strong> (currently <code>:s</code> and <code>:a</code>), treating the entire DDN as a single black box.</p><ul><li>This is the version that solvers and simulators should call.</li><li>Example (called in a solver): <code>sp, o, r = gen(DDNOut(:sp,:o,:r), m, s, a, rng)</code></li><li>This function is automatically synthesized by POMDPs.jl by combining <code>gen(m, s, a, rng)</code> and <code>gen(::DDNNode, ...)</code> or <a href="../explicit/#explicit_doc-1">explicit model definitions</a> for all <a href="../ddns/#Dynamic-Decision-Networks-1">DDN nodes</a>.</li><li>This version should only be implemented directly by problem writers in very rare cases when they need precise control for efficiency.</li></ul></li></ul><p>In all versions, <code>m</code> is a (PO)MDP model, and <code>rng</code> is a <a href="#Random-number-generators-1">random number generator</a>.</p><h2 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h2><p>An example of defining a problem with the generative interface can be found <a href="https://github.com/JuliaPOMDP/POMDPExamples.jl/blob/master/notebooks/Defining-a-POMDP-with-the-Generative-Interface.ipynb">in the POMDPExamples package</a>.</p><h2 id="Random-number-generators-1"><a class="docs-heading-anchor" href="#Random-number-generators-1">Random number generators</a><a class="docs-heading-anchor-permalink" href="#Random-number-generators-1" title="Permalink"></a></h2><p>The <code>rng</code> argument to functions in the generative interface is a random number generator such as <code>Random.GLOBAL_RNG</code> or another <code>MersenneTwister</code>. It should be used to generate all random numbers within the function (e.g. use <code>rand(rng)</code> instead of <code>rand()</code>). This will ensure that all simulations are exactly repeatable. See the <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Random-Numbers-1">Julia documentation on random numbers</a> for more information about these objects.</p><h2 id="Performance-considerations-1"><a class="docs-heading-anchor" href="#Performance-considerations-1">Performance considerations</a><a class="docs-heading-anchor-permalink" href="#Performance-considerations-1" title="Permalink"></a></h2><p>In general, calling <code>gen(::DDNOut, ...)</code> when <code>gen(::POMDP, ...)</code> is implemented does not introduce much overhead. In fact, in some cases, the compiler will even optimize out calculations of extra genvars. For example:</p><pre><code class="language-julia">struct M &lt;: MDP{Int, Int} end

POMDPs.gen(::M, s, a, rng) = (sp=s+a, r=s^2)

@code_warntype gen(DDNOut(:sp), M(), 1, 1, Random.GLOBAL_RNG)</code></pre><p>will yield</p><pre><code class="language-none">Body::Int64
1 ─ %1 = (Base.add_int)(s, a)::Int64
│        nothing
└──      return %1</code></pre><p>indicating that the compiler will only perform the addition to find the next state and skip the <code>s^2</code> calculation for the reward.</p><p>Unfortunately, if random numbers are used in <code>gen</code>, the compiler will not be able to optimize out the change in the rng&#39;s state, so it may be beneficial to directly implement versions of <code>gen(::DDNNode, ...)</code>. For example</p><pre><code class="language-julia">POMDPs.gen(::DDNNode{:sp}, ::M, s, a, rng) = s+a
POMDPs.reward(::M, s, a) = abs(s)
PODMPs.gen(::DDNNode{:o}, ::M, s, a, sp, rng) = sp+randn(rng)</code></pre><p>might be more efficient than</p><pre><code class="language-julia">function POMDPs.gen(::M, s, a, rng)
    sp = s + a
    return (sp=sp, r=abs(s), o=sp+randn(rng))
end</code></pre><p>in the context of particle filtering.</p><p>As always, though, one should resist the urge towards premature optimization; careful profiling to see what is actually slow is much more effective than speculation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../explicit/">« Explicit (PO)MDP Interface</a><a class="docs-footer-nextpage" href="../interfaces/">Spaces and Distributions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 5 April 2020 06:37">Sunday 5 April 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
